# iot-cpp-2025
C++

## 1일차
- 객체지향언어 : 대규모 팀 프로젝트 개발에 최적화 > 클래스
- 입출력 연산자
	- `cout` : 출력을 담당하는 객체
	- `cin` : 입력을 담당하는 객체
- `namespace` : [C++](./Day01/namesp.cpp) 이름 충돌을 방지하기 위한 방법으로 다른 이름 공간을 만들어서 구분
	- 관련된 함수나 클래스, 변수들을 하나의 이름 공간으로 묶는 방법
	- 서로 다른 namespace에 동일한 이름의 함수나 변수가 있을 경우, 충돌 없이 사용 가능
- `Refernce`(참조자) : [C++](./Day01/)
	- **선언시 초기화 필수** : [C++](./Day01/ref3.cpp)
	- 다른 함수에 선언된 지역변수의 값을 바꾸는 방법
	- 보이지 않는 포인터, 변수이름에 또다른 이름을 주는 것
	- 메모리를 사용하지 않아 효율적, 포인터 변수의 경우 주소를 저장할 메모리공간 할당 필요(스택영역 4btye)
	- 상수 참조 : [C++](./Day01/ref5.cpp)
		- lvalue 참조자 > 변수
		- rvalue 참조자 > 상수 (rvalue 변수도 가능은 함) [C++](./Day01/ref4.cpp)
- `new`(생성자) :[C++](./Day01/new2.cpp) 객체를 생성하고, 초기화시키는 기능을 가지는 특별한 메서드
	- new는 생성자 호출이 되므로 초기화 가능
	- 객체 생성 시 자동 호출
- `delete`(소멸자) : [C++](./Day01/new2.cpp)
	- 객체가 소멸될 때 자동 호출되는 메서드
- `default` : [C++](./Day01/default2.cpp)
	- default 매개변수 여러개 사용시 맨 오른쪽부터 순서 적용
	- [C++](./Day01/default.cpp) 입력이 없을시 디폴트 매개변수 적용
	- [C++](./Day01/default3.cpp) 함수 오버로딩중에서 디폴트 매개변수와 입력이 없는 순수한 함수 정의가 있을 때 입력없는 함수 호출시 문제 발생
- `struct`(구조체) : [C++](./Day01/st_c2.cpp) 멤버변수 + 멤버함수(구조체 멤버이므로 .연산자로 접근 가능)
	```c
	typedef struct human{
		char name[20];
		int age;
		char job[10];

		void showHuman() {
			printf("name: %s, age: %d, job: %s", name, age, job);	// 구조체 안으로 들어갔기 때문에 .으로 접근할 필요 없음
		}
	} Human;
	```
- `class`(클래스) : [C++](./Day01/st_c3.cpp) 사용자가 만든 자료형 
	
	```c
	class Human {
	public:
		char name[20];
		int age;
		char job[10];
		// 생성자 호출
		Human(char name) {		// 디폴트 생성자
			
		}
		void showHuman() {
			printf("name: %s, age: %d, job: %s", name, age, job);	// 구조체 안으로 들어갔기 때문에 접근할 필요 없음
		}
	};
	```
- this 포인터 : 객체 자기자신을 가리키는 포인터
- 함수 다형성
	- OverLoading : [C++](./Day01/overloading.cpp) 함수의 다중정의 > 동일한 함수명이나 매개변수의 타입과 개수가 다르면 다른 함수
	- OverRiding : 함수의 재정의 -> 상속
	- C++ 함수 구분
		- 함수명 같아도 되나 매개변수까지 같아야 동일 함수 취급
		- 매개변수 타입 및 개수가 달라야 함 > 오버로딩 가능한 이유

## 2일차
- `class` 구성요소 3가지
	1. 접근제어 지시자(private, public, protected : 접근 제어 범위) 
		- 디폴드 값 : private
	2. 멤버 변수 - 속성을 멤버 변수로 선언
		- private 영역 
	3. 멤버 함수(메서드) - 기능 구현
		- public 영역
- 초기화 시키는 함수
	- 생성자 : [C++](./Day02/class3.cpp)객체를 생성하면서 초기값 함께 줄 수 있음
		- 생성자 호출로 객체 생성
		- 객체 생성시 구조에 맞는 생성자가 없으면 객체 미생성
		- 초기화 기능에 사용
		- 오버로딩 가능
		- 생성자를 작성하면 더 이상 디폴트 생성자는 제공되지 않음
		- [C++](./Day02/init4.cpp)콜론 초기화, 이니셜라이져 리스트 > `생성자(매개변수) ':' 멤버변수(매개변수)` {}
	- 소멸자 : 객체를 소멸 시킴. 디폴트로 자동 호출되므로 동적 할당한 경우 아니면 별도 작성하지 않아도 됨!
		- 사용방법 : 생성자 맨 앞에 ~ 붙일 것
		- [C++](./Day02/MyClass3.cpp) new 사용하여 메모리 동적 할당 받은 후 delete를 소멸자안에서 사용
		'''c
		MyClass() {} 	// 생성자
		~MyClass() {	// 소멸자
			delete[] p	// 포인터 배열 p 메모리 반환
		}
		'''
- 객체, 인스턴스 차이
	- 객체 : 클래스(Class)로부터 만들어진 모든 실체(메모리에 존재하는 것)를 의미
	- 인스턴스 : 특정 클래스의 객체를 가리킬 때 사용되는 용어
	'''c
		class A{}
		A obj // 클래스A의 객체obj 생성 == obj는 클래스A의 인스턴스 (어떤 객체가 특정 클래스의 인스턴스)
	'''
	- 클래스에 중점을 두고 접근하면 인스턴스
	- 객체를 생성하기 위해 생성자가 호출됨

- 문자열 정리 : [C++](./Day02/문자열처리하기.cpp)

- 변수 초기화 : [C++](./Day02/init.cpp)
	- [C++](./Day02/init3.cpp) 생성자 초기화 3가지 방법
		- 복사 초기화
		- 직접 초기화
		- 이니셜라이져 리스트(Initializer List)
- 상수 초기화 : [C++](./Day02/init4.cpp)
	- **선언과 동시에 초기화!**